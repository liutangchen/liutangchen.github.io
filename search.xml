<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AOP(JDK动态代理)</title>
    <url>/2020/10/29/AOP-JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<ol>
<li><p>使用 JDK 动态代理，使用包 java.lang.reflect 下的 Proxy 类里面的方法 newProxyInstance(ClassLoader loader,类&lt;?&gt;[] interfaces,InvocationHandler h) 创建代理对象</p>
<p>方法有三个参数：</p>
<p>第一个参数：类加载器</p>
<p>第二个参数：增强方法所在的类，这个类实现的接口，支持多个接口</p>
<p>第三个参数：实现这个接口InvocationHandler,创建代理对象，写增强部分</p>
</li>
</ol>
<a id="more"></a>

<ol start="2">
<li><p>编写 JDK 动态代理代码</p>
<p>（1）创建接口，定义方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">update</span><span class="params">(String id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）创建接口实现类，实现方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">update</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）使用 Proxy 类创建接口代理对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKProxy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建接口实现类代理对象</span></span><br><span class="line">        Class[] interfaces = &#123;UserDao.class&#125;;</span><br><span class="line">        UserDaoImpl userDao = <span class="keyword">new</span> UserDaoImpl();</span><br><span class="line">        UserDao dao = (UserDao) Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, <span class="keyword">new</span> UserDaoProxy(userDao));</span><br><span class="line">        <span class="keyword">int</span> result = dao.add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;result:&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建代理对象代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserDaoProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 把创建的是谁的代理对象，把谁传递过来 </span></span><br><span class="line">    <span class="comment">// 有参数构造传递</span></span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserDaoProxy</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增强的逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 方法之前</span></span><br><span class="line">        System.out.println(<span class="string">&quot;方法之前执行....&quot;</span> + method.getName() + <span class="string">&quot; :传递的参 数...&quot;</span> + Arrays.toString(args));</span><br><span class="line">        <span class="comment">// 被增强的方法执行</span></span><br><span class="line">        Object res = method.invoke(obj, args);</span><br><span class="line">        <span class="comment">// 方法之后</span></span><br><span class="line">        System.out.println(<span class="string">&quot;方法之后执行....&quot;</span> + obj);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>IOC的理解</title>
    <url>/2020/10/25/IOC%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="IOC-概念和原理"><a href="#IOC-概念和原理" class="headerlink" title="IOC(概念和原理)"></a>IOC(概念和原理)</h1><h2 id="什么是IOC"><a href="#什么是IOC" class="headerlink" title="什么是IOC"></a>什么是IOC</h2><p>控制反转，把对象创建和对象之间的调用过程，交给spring进行管理;IOC思想基于IOC容器完成，IOC容器底层就是对象工厂；使用IOC的目的就是为了降低耦合度</p>
<a id="more"></a>

<h2 id="IOC底层原理"><a href="#IOC底层原理" class="headerlink" title="IOC底层原理"></a>IOC底层原理</h2><ol>
<li>xml解析</li>
<li>工厂模式</li>
<li>反射</li>
</ol>
<h2 id="图解IOC底层原理"><a href="#图解IOC底层原理" class="headerlink" title="图解IOC底层原理"></a>图解IOC底层原理</h2><img src="/2020/10/25/IOC%E7%9A%84%E7%90%86%E8%A7%A3/1.png" class="" title="This is an image">

<h1 id="IOC-BeanFactory-接口"><a href="#IOC-BeanFactory-接口" class="headerlink" title="IOC(BeanFactory 接口)"></a>IOC(BeanFactory 接口)</h1><h2 id="spring提供IOC容器实现两种方式：（两个接口）"><a href="#spring提供IOC容器实现两种方式：（两个接口）" class="headerlink" title="spring提供IOC容器实现两种方式：（两个接口）"></a>spring提供IOC容器实现两种方式：（两个接口）</h2><ol>
<li>BeanFactory:IOC容器基本实现，是spring内部的使用接口，不提供开发人员进行使用；在加载配置文件时候不会创建对象，在获取对象（使用）才去创建对象</li>
<li>ApplicationContext:BeanFactory接口的子接口，提供更多更强大的功能，一般由开发人员进行使用；加载配置文件时候就会把在配置文件对象创建</li>
</ol>
<h2 id="ApplicationContext接口的实现类："><a href="#ApplicationContext接口的实现类：" class="headerlink" title="ApplicationContext接口的实现类："></a>ApplicationContext接口的实现类：</h2><img src="/2020/10/25/IOC%E7%9A%84%E7%90%86%E8%A7%A3/2.png" class="" title="This is an image">

<h1 id="IOC操作Bean管理（bean作用域）"><a href="#IOC操作Bean管理（bean作用域）" class="headerlink" title="IOC操作Bean管理（bean作用域）"></a>IOC操作Bean管理（bean作用域）</h1><ol>
<li>在spring里面，默认情况下，bean是单实例对象</li>
</ol>
<img src="/2020/10/25/IOC%E7%9A%84%E7%90%86%E8%A7%A3/3.png" class="" title="This is an image">

<ol start="2">
<li><p>如何设置单实例还是多实例</p>
<p> （1）在spring配置文件bean标签里面有属性（scope）用于设置单实例还是多实例</p>
<p> （2）scope属性值：默认为（singleton）,表示是单实例对象；另一个值为（prototype）,表示是多实例对象。</p>
</li>
</ol>
<img src="/2020/10/25/IOC%E7%9A%84%E7%90%86%E8%A7%A3/4.png" class="" title="This is an image">

<ol start="3">
<li><p>singleton和prototype的区别</p>
<p> （1）singleton单实例，prototype多实例</p>
<p> （2）设置scope值是singleton的时候，加载spring配置文件时候就会创建单实例对象；设置scope值是prototype的时候，不是在加载spring配置文件时候创建对象，而是在调用getBean方法时创建多实例对象</p>
</li>
</ol>
<h1 id="IOC操作Bean管理-bean的生命周期"><a href="#IOC操作Bean管理-bean的生命周期" class="headerlink" title="IOC操作Bean管理(bean的生命周期)"></a>IOC操作Bean管理(bean的生命周期)</h1><ol>
<li><p>什么是bean的生命周期<br> 从对象创建到对象销毁的过程。</p>
</li>
<li><p>bean的生命周期</p>
<p> （1）通过构造器创建bean实例（无参构造器）</p>
<p> （2）为bean的属性设置值和对其他bean的引用（调用set方法）</p>
<p> （3）调用bean的初始化方法（需要进行配置初始化的方法）</p>
<p> （4）bean可以使用了（对象获取到了）</p>
<p> （5）当容器关闭时，调用bean的销毁的方法（需要进行配置销毁方法）</p>
</li>
<li><p>代码演示bean的生命周期</p>
<p> (1) 创建Orders类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Orders</span></span>&#123;</span><br><span class="line">    <span class="comment">//无参数构造</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Orders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第一步 执行无参数构造创建 bean 实例&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String oname;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOname</span><span class="params">(String oname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.oname = oname;</span><br><span class="line">        System.out.println(<span class="string">&quot;第二步 调用 set 方法设置属性值&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建执行的初始化的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第三步 执行初始化的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建执行的销毁的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第五步 执行销毁的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> （2）xml文件中配置bean</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;orders&quot; class&#x3D;&quot;com.atguigu.spring5.bean.Orders&quot; init-method&#x3D;&quot;initMethod&quot; destroy-method&#x3D;&quot;destroyMethod&quot;&gt;</span><br><span class="line">	&lt;property name&#x3D;&quot;oname&quot; value&#x3D;&quot;手机&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p> (3)创建测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBean3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;bean4.xml&quot;</span>);</span><br><span class="line">    ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;bean4.xml&quot;</span>);</span><br><span class="line">    Orders orders = context.getBean(<span class="string">&quot;orders&quot;</span>, Orders.class);</span><br><span class="line">    System.out.println(<span class="string">&quot;第四步 获取创建 bean 实例对象&quot;</span>);</span><br><span class="line">    System.out.println(orders);</span><br><span class="line">    <span class="comment">//手动让 bean 实例销毁</span></span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> (4)测试结果</p>
</li>
</ol>
<img src="/2020/10/25/IOC%E7%9A%84%E7%90%86%E8%A7%A3/5.png" class="" title="This is an image">

<ol start="4">
<li><p>bean的后置处理器，bean的生命周期有七步</p>
<p> （1）通过构造器创建bean实例（无参构造器）</p>
<p> （2）为bean的属性设置值和对其他bean的引用（调用set方法）</p>
<p> （3）把bean实例传递bean后置处理器的方法postProcessBeforeInitialization</p>
<p> （4）调用bean的初始化方法（需要进行配置初始化的方法）</p>
<p> （5）把bean实例传递bean后置处理器的方法postProcessAfterInitialization</p>
<p> （6）bean可以使用了（对象获取到了）</p>
<p> （7）当容器关闭时，调用bean的销毁的方法（需要进行配置销毁方法）</p>
</li>
<li><p>演示添加后置处理器效果</p>
<p> （1）创建类，实现接口BeanPostProcessor，创建后置处理器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPost</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在初始化之前执行的方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在初始化之后执行的方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> （2）在xml文件中配置后置处理器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;myBeanPost&quot; class&#x3D;&quot;com.atguigu.spring5.bean.MyBeanPost&quot;&gt;&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p> （3）配置后置处理器的测试结果</p>
</li>
</ol>
<img src="/2020/10/25/IOC%E7%9A%84%E7%90%86%E8%A7%A3/6.png" class="" title="This is an image">

<h1 id="IOC-操作-Bean管理-基于注解方式"><a href="#IOC-操作-Bean管理-基于注解方式" class="headerlink" title="IOC 操作 Bean管理(基于注解方式)"></a>IOC 操作 Bean管理(基于注解方式)</h1><ol>
<li><p>什么是注解</p>
<p>（1）注解是代码特殊标记，格式:@注解名称(属性名称=属性值, 属性名称=属性值..)</p>
<p>（2）使用注解，注解作用在类上面，方法上面，属性上面</p>
<p>（3）使用注解的目的：简化xml配置</p>
</li>
<li><p>Spring 针对 Bean 管理中创建对象提供的注解</p>
<p>（1）@Component</p>
<p>（2）@Service</p>
<p>（3）@Controller</p>
<p>（4）@Repository</p>
<p>*上面四个注解功能是一样的，都可以用来创建bean实例</p>
</li>
<li><p>基于注解方式实现属性注入</p>
<p>（1）@Autowired:根据<strong>属性类型</strong>进行自动装配（<strong>注意：</strong>如果需要注入一个接口实现类的对象，但此接口有多个实现类，此时光靠@Autowired无法完成，需要@Qualifier指定<strong>名称</strong>根据名称完成注入）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 定义dao类型属性 </span></span><br><span class="line">    <span class="comment">// 不需要添加set方法 </span></span><br><span class="line">    <span class="comment">// 添加注入属性注解</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;  <span class="comment">// UserDao接口的实现类只能有一个 </span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service add.......&quot;</span>);</span><br><span class="line">        userDao.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）@Qualifier:根据<strong>名称</strong>进行注入，它的作用是在按照类中注入的基础之上再按照名称注入；它在给类成员注入时不能单独使用（但是在给方法参数注入时可以单独使用），<strong>因此@Qualifier常常组合@Autowired一起使用，用来指明具体名字的自动装配</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span> <span class="comment">//根据类型进行注入</span></span><br><span class="line"><span class="meta">@Qualifier(value = &quot;userDaoImpl1&quot;)</span> <span class="comment">//根据名称进行注入 </span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;  <span class="comment">// UserDao接口的实现类有多个</span></span><br></pre></td></tr></table></figure>

<p>（3）@Resource:可以根据<strong>类型</strong>注入，也可以根据<strong>名称</strong>注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@Resource  // 根据类型进行注入</span></span><br><span class="line"><span class="meta">@Resource(name = &quot;userDaoImpl1&quot;)</span> <span class="comment">// 根据名称进行注入 </span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br></pre></td></tr></table></figure>

<p>（4）@Value:注入普通类型属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value(value = &quot;abc&quot;)</span> </span><br><span class="line"><span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure>







</li>
</ol>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/10/22/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>JVM内存模型</title>
    <url>/2020/10/24/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h1><h2 id="JVM回顾"><a href="#JVM回顾" class="headerlink" title="JVM回顾"></a>JVM回顾</h2><p>JVM = 类加载器(classloader) + 执行引擎(execution engine) + 运行时数据区域(runtime data area)</p>
<img src="/2020/10/24/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1.png" class="" title="This is an image">

<a id="more"></a>
<h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。</p>
<img src="/2020/10/24/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/2.png" class="" title="This is an image">

<h3 id="程序计数器（Program-Counter-Register）"><a href="#程序计数器（Program-Counter-Register）" class="headerlink" title="程序计数器（Program Counter Register）"></a>程序计数器（Program Counter Register）</h3><ul>
<li>线程私有，它的生命周期与线程相同。</li>
<li>可以看做是当前线程所执行的字节码的行号指示器。</li>
<li>在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，如：分支、循环、跳转、异常处理、线程恢复（多线程切换）等基础功能。 </li>
<li>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie方法，这个计数器值则为空（undefined）。</li>
<li>程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，所以此区域不会出现OutOfMemoryError的情况。</li>
</ul>
<h3 id="Java虚拟机栈（JVM-Stacks）"><a href="#Java虚拟机栈（JVM-Stacks）" class="headerlink" title="Java虚拟机栈（JVM Stacks）"></a>Java虚拟机栈（JVM Stacks）</h3><ul>
<li>线程私有的，它的生命周期与线程相同。</li>
<li>虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</li>
<li>局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型），它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</li>
<li>该区域可能抛出以下异常：<ol>
<li>当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；</li>
<li>栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。</li>
</ol>
</li>
</ul>
<h3 id="本地方法栈（Native-Method-Stacks）"><a href="#本地方法栈（Native-Method-Stacks）" class="headerlink" title="本地方法栈（Native Method Stacks）"></a>本地方法栈（Native Method Stacks）</h3><ul>
<li>与虚拟机栈非常相似，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native 方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot 虚拟机）直接就把本地方法栈和虚拟机栈合二为一。</li>
<li>与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</li>
</ul>
<h3 id="Java堆（Heap）"><a href="#Java堆（Heap）" class="headerlink" title="Java堆（Heap）"></a>Java堆（Heap）</h3><ul>
<li>被所有线程共享，在虚拟机启动时创建，用来存放对象实例，几乎所有的对象实例都在这里分配内存。</li>
<li>对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。</li>
<li>Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：新生代和老年代；新生代又有Eden空间、From Survivor空间、To Survivor空间三部分。</li>
<li>Java 堆不需要连续内存，并且可以通过动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。</li>
</ul>
<img src="/2020/10/24/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/3.png" class="" title="This is an image">

<h3 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h3><ul>
<li>用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</li>
<li>和Java堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出OutOfMemoryError 异常。</li>
<li>对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现，HotSpot 虚拟机把它当成永久代（Permanent Generation）来进行垃圾回收。</li>
<li>方法区逻辑上属于堆的一部分，但是为了与堆进行区分，通常又叫“非堆”。</li>
</ul>
<p>参考链接：  </p>
<ol>
<li><a href="https://juejin.im/entry/6844903585231159309">jvm内存模型-1</a></li>
<li><a href="https://www.cnblogs.com/wupeixuan/p/8650455.html">jvm内存模型-2</a></li>
</ol>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
</search>
